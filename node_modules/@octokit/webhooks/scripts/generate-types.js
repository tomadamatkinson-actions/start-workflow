const fs = require("fs");

const { pascalCase } = require("pascal-case");
const prettier = require("prettier");
const TypeWriter = require("@gimenete/type-writer");
const webhooks = require("@octokit/webhooks-definitions");

const eventTypes = ['type EventTypeError = "error"', 'type AnyEvent = "*"'];

const conditionalType = [
  `type GetWebhookPayloadTypeFromEvent<T> = `,
  `T extends EventTypeError ? Error :`,
  `T extends AnyEvent ? any :`,
];

const tw = new TypeWriter();

webhooks.forEach(({ name, actions, examples }) => {
  if (!examples) {
    return;
  }

  const typeName = `WebhookPayload${pascalCase(name)}`;
  tw.add(examples, {
    rootTypeName: typeName,
    namedKeyPaths: {
      [`${typeName}.repository`]: "PayloadRepository",
      // This prevents a naming colision between the payload of a `installation_repositories` event
      // and the `repositories` attribute of a `installation` event
      "WebhookPayloadInstallation.repositories":
        "WebhookPayloadInstallation_Repositories",
    },
  });

  const events = [
    `'${name}'`,
    ...actions.map((action) => `'${name}.${action}'`),
  ].join(" |Â ");
  const eventTypeName = `${typeName}EventTypeKeys`;
  const type = `type ${eventTypeName} = ${events};`;
  eventTypes.push(type);
  conditionalType.push(
    `T extends ${eventTypeName} ? Webhooks.WebhookEvent<Webhooks.${typeName}> :`
  );
});

conditionalType.push(`never;`);
const definition = `
// DO NOT EDIT THIS FILE DIRECTLY
// make edits in scripts/generate-types.js

import http = require('http')

type Options = {
  secret: string
  path?: string
  transform?: (event: Webhooks.WebhookEvent<any>) => Webhooks.WebhookEvent<any> & { [key: string]: any }
}

declare namespace Webhooks {
  ${tw.generate("typescript", { inlined: false })}

  interface WebhookEvent<T> {
    id: string
    name: string
    payload: T
    protocol?: 'http' | 'https'
    host?: string
    url?: string
  }
}

${eventTypes.join("\n")}

type AllEventTypes = ${eventTypes
  .map((event) => event.split(" ")[1])
  .join(" | ")};

${conditionalType.join("\n")}

declare class Webhooks {
  constructor (options?: Options)
  public on <T extends AllEventTypes>(event: T | T[], callback: (event: GetWebhookPayloadTypeFromEvent<T>) => Promise<void> | void): void
  public sign (data: any): string
  public verify (eventPayload: any, signature: string): boolean
  public verifyAndReceive (options: { id: string, name: string, payload: any, signature: string }): Promise<void>
  public receive (options: { id: string, name: string, payload: any }): Promise<void>
  public removeListener <T extends AllEventTypes>(event: T | T[], callback: (event: GetWebhookPayloadTypeFromEvent<T>) => Promise<void> | void): void
  public middleware (request: http.IncomingMessage, response: http.ServerResponse, next?: (err?: any) => void): void | Promise<void>
}

export function createWebhooksApi(options?: Options): Webhooks;
export function createEventHandler(options?: Options): Webhooks;
export function createMiddleware(options?: Options): Webhooks;
export function sign(data: any): string
export function verify(eventPayload: any, signature: string): boolean

export default Webhooks;
export { Webhooks };
`;

const filepath = "index.d.ts";
const output = prettier.format(definition, {
  filepath,
});
fs.writeFileSync(filepath, output);
